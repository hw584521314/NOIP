#include<stdio.h>
//标志位，表示是否已经被走过了，0表示未走过，1表示走过 
int a[5]={0};
//结果缓冲区 
int stack[5]={0};
//有向图的邻接矩阵 
int b[5][5]={
{0,0,1,1,1},
{1,0,0,0,0},
{0,0,0,1,1},
{0,0,0,0,1},
{0,0,0,0,0}};
//len主要用来跟踪结果栈。 
void f(int x,int len)
{
	int flag=0;//标志位，看是否已经无路可走。如果对列都遍历过了，都没有一个满足，就表示无路可走 
	//对0-5列依次检查是否有可用的点 
	for(int i=0;i<5;i++)
	{
		if(b[x][i]==1&&a[i]==0)
		{//如果点可用，则占用该点，并压入栈 。然后继续DFS 
			a[i]=1;
			stack[len]=i;
			f(i,len+1);
			a[i]=0;//清理对点的占用，则下一次循环可以恢复环境。压入栈则由len局部变量自动清理 
			flag=1;
		}
	}
	if(flag==0)
	{//无路可走，打印结果 
		for(int i=0;i<len;i++)
		{
			printf("%d,",stack[i]);
		}
		printf("\n");
	}
} 
	
int main()
{
	//把1号先放进去，从它开始遍历 
	/*
	a[1]=1;
	stack[0]=1; 
	f(1,1);
	*/
	//把0号放进去，试试 
	a[0]=1;
	stack[0]=0; 
	f(0,1);
}
